---
title: "Constructing Non-Hierarchical P/NBD Models"
author: "Mick Cooney <mickcooney@gmail.com>"
date: "Last updated: `r format(Sys.time(), '%B %d, %Y')`"
editor: source
execute:
  message: false
  warning: false
  error: false
format:
  html:
    light: superhero
    dark: darkly
    anchor-sections: true
    embed-resources: true
    number-sections: true
    smooth-scroll: true
    toc: true
    toc-depth: 3
    toc-location: left
    code-fold: true
    code-summary: "Show code"
---


```{r import_libraries}
#| echo: FALSE
#| message: FALSE

library(conflicted)
library(tidyverse)
library(scales)
library(cowplot)
library(directlabels)
library(magrittr)
library(rlang)
library(fs)
library(purrr)
library(furrr)
library(glue)
library(cmdstanr)
library(brms)
library(posterior)
library(bayesplot)
library(tidybayes)


source("lib_utils.R")
source("lib_btyd.R")


conflict_lst <- resolve_conflicts(
  c("magrittr", "rlang", "dplyr", "readr", "purrr", "ggplot2", "MASS",
    "fitdistrplus")
  )


knitr::opts_chunk$set(
  tidy       = FALSE,
  cache      = FALSE,
  warning    = FALSE,
  message    = FALSE,
  fig.height =     8,
  fig.width  =    11
  )

options(
  width = 80L,
  warn  = 1,
  mc.cores = parallel::detectCores()
  )

theme_set(theme_cowplot())

set.seed(42)

plan(multisession)
```

In this workbook we expand on our initial exploration of the P/NBD models and
build some infrastructure allowing us to build and fit multiple models with
different sets of data.



# Build Short Timeframe P/NBD Models

We start with the synthetic data over the short time frame to begin.


```{r set_start_end_dates}
use_fit_start_date <- as.Date("2020-01-01")
use_fit_end_date   <- as.Date("2022-01-01")

use_valid_start_date <- as.Date("2022-01-01")
use_valid_end_date   <- as.Date("2023-01-01")
```


## Load Short Time-frame Synthetic Data

We load our short time frame data once again, setting up the data points and
also our input parameters, so we can check how effectively the model fits
capture the true underlying parameters.


```{r load_shortframe_synthetic_data}
#| echo: TRUE

customer_cohortdata_tbl <- read_rds("data/synthdata_shortframe_cohort_tbl.rds")
customer_cohortdata_tbl |> glimpse()

customer_simparams_tbl  <- read_rds("data/synthdata_shortframe_simparams_tbl.rds")
customer_simparams_tbl |> glimpse()

customer_transactions_tbl <- read_rds("data/synthdata_shortframe_transactions_tbl.rds")
customer_transactions_tbl |> glimpse()
```


## Load Modelling Data

We calculate summary statistics on this data, and use this data as our fitting
data.

We also want to calculate summary statistics for the validation period as well.

As before, we begin with 1,000 customers - purely to shorten the computation
time as we experiment and explore the model.

```{r load_modelling_fit_data}
#| echo: true

cust_id <- read_rds("data/shortframe_id_1000.rds")

customer_fit_stats_tbl <- customer_transactions_tbl |>
  calculate_transaction_cbs_data(last_date = use_fit_end_date) |>
  filter(customer_id %in% cust_id)

customer_fit_stats_tbl |> glimpse()
```

We also want to calculate the summary statistics, both for the fit data and
the validation data.

```{r load_modelling_valid_data}
customer_valid_stats_tbl <- customer_transactions_tbl |>
  filter(
    customer_id %in% cust_id,
    tnx_timestamp >= use_valid_start_date
    ) |>
  calculate_transaction_cbs_data(last_date = use_valid_end_date)

customer_valid_stats_tbl |> glimpse()
```


# Fit First Fixed-Prior P/NBD Model

We now construct our Stan model and prepare to fit it with our synthetic
dataset.

Before we start on that, we set a few parameters for the workbook to organise
our Stan code.

```{r setup_workbook_parameters}
#| echo: TRUE

stan_modeldir <- "stan_models"
stan_codedir  <-   "stan_code"
```


We start with the Stan model.

```{r display_pnbd_fixed_model_stancode}
#| echo: FALSE

read_lines("stan_code/pnbd_fixed.stan") |> cat(sep = "\n")
```

This file contains a few new features of Stan - named file includes and
user-defined functions - `calculate_pnbd_loglik`. We look at this file here:

```{r display_util_functions_stancode}
#| echo: FALSE

read_lines("stan_code/util_functions.stan") |> cat(sep = "\n")
```

We now compile this model using `CmdStanR`.

```{r compile_pnbd_fixed_stanmodel}
#| echo: TRUE
#| results: "hide"

pnbd_fixed_stanmodel <- cmdstan_model(
  "stan_code/pnbd_fixed.stan",
  include_paths =   stan_codedir,
  pedantic      =           TRUE,
  dir           =  stan_modeldir
  )
```


We then use this compiled model with our data to produce a fit of the data.

```{r fit_pnbd_fixed_stanmodel}
#| echo: TRUE
#| cache: TRUE

stan_modelname <- "pnbd_nonhier_fixed"
stanfit_prefix <- str_c("fit_", stan_modelname) 

stan_data_lst <- customer_fit_stats_tbl |>
  select(customer_id, x, t_x, T_cal) |>
  compose_data(
    lambda_mn = 0.25,
    lambda_cv = 1.00,
    
    mu_mn     = 0.10,
    mu_cv     = 1.00,
    )

pnbd_nonhier_fixed_stanfit <- pnbd_fixed_stanmodel$sample(
  data            =                stan_data_lst,
  chains          =                            4,
  iter_warmup     =                          500,
  iter_sampling   =                          500,
  seed            =                         4201,
  save_warmup     =                         TRUE,
  output_dir      =                stan_modeldir,
  output_basename =               stanfit_prefix,
  )

pnbd_nonhier_fixed_stanfit$summary()
```


We have some basic HMC-based validity statistics we can check.

```{r calculate_pnbd_fixed_hmc_diagnostics}
#| echo: TRUE

pnbd_nonhier_fixed_stanfit$cmdstan_diagnose()
```



## Visual Diagnostics of the Sample Validity

We need to check some diagnostics to assess the validity of the sample fit from
the MCMC work, but our visualisations will not be as comprehensive for this
workbook, just showing a summary of the plots. In particular we show the
traceplots and $N_{eff}$.

```{r plot_pnbd_nonhier_fixed_diagnostics}
#| echo: TRUE

parameter_subset <- c(
  "lambda[1]", "lambda[2]", "lambda[3]", "lambda[4]",
  "mu[1]",     "mu[2]",     "mu[3]",     "mu[4]"
  )

pnbd_nonhier_fixed_stanfit$draws(inc_warmup = FALSE) |>
  mcmc_trace(pars = parameter_subset) +
  expand_limits(y = 0) +
  labs(
    x = "Iteration",
    y = "Value",
    title = "Traceplot of Sample of Lambda and Mu Values"
    ) +
  theme(axis.text.x = element_text(size = 10))


pnbd_nonhier_fixed_stanfit |>
  neff_ratio(pars = c("lambda", "mu")) |>
  as.numeric() |>
  mcmc_neff() +
    ggtitle("Plot of Parameter Effective Sample Sizes")
```



## Check Model Fit

As we are still working with synthetic data, we know the true values for each
customer and so we can check how good our model is at recovering the true
values on a customer-by-customer basis.

As in previous workbooks, we build our validation datasets and then check the
distribution of $q$-values for both $\lambda$ and $\mu$ across the customer
base.


```{r construct_pnbd_fixed_validation_qvalues}
#| echo: TRUE

pnbd_nonhier_fixed_valid_lst <- create_pnbd_posterior_validation_data(
  stanfit       = pnbd_nonhier_fixed_stanfit,
  data_tbl      = customer_fit_stats_tbl,
  simparams_tbl = customer_simparams_tbl
  )

pnbd_nonhier_fixed_valid_lst$lambda_qval_plot |> plot()

pnbd_nonhier_fixed_valid_lst$mu_qval_plot |> plot()
```

These plots looks like the model is recovering the parameters well, but cannot
rely on this approach once we use real data so we will stop using this now.

Instead, we will look at using our posterior sample to generate data and
compare this simulated data against the data we fit. This procedure is similar
to what we did before but now we focus on in sample data rather than using
validation data.


```{r calculate_pnbd_posterior_simstats}
#| echo: TRUE
#| cache: TRUE

sim_stats_tbl <- construct_pnbd_posterior_statistics(
  stanfit         = pnbd_nonhier_fixed_stanfit,
  fitdata_tbl     = customer_fit_stats_tbl
  )

sim_stats_tbl |> glimpse()
```

We then use these posterior statistics as inputs to our simulations to help
us assess the in-sample quality of fit.


```{r generate_pnbd_nonhier_fixed_fitdata_transactions}
#| echo: TRUE

plan(multisession)

fit_label <- "pnbd_nonhier_fixed"

precompute_dir <- glue("precompute/{fit_label}")

ensure_exists_precompute_directory(precompute_dir)


precomputed_tbl <- dir_ls(glue("{precompute_dir}")) |>
  as.character() |>
  enframe(name = NULL, value = "sim_file")

pnbd_nonhier_fixed_validsims_index_tbl <- sim_stats_tbl |>
  mutate(
    start_dttm = first_tnx_date,
    end_dttm   = as.Date("")
    end_dttm   = c(),
    lambda     = post_lambda,
    mu         = post_mu,
    tnx_mu     = 1,
    tnx_cv     = 1
    ) |>
  group_nest(customer_id, .key = "cust_params") |>
  mutate(
    sim_file = glue(
      "{precompute_dir}/sims_fit_{fit_label}_{customer_id}.rds"
      )
    )


runsims_tbl <- pnbd_nonhier_fixed_validsims_index_tbl |>
  anti_join(precomputed_tbl, by = "sim_file")



if(nrow(runsims_tbl) > 0) {
  pnbd_nonhier_fixed_validsims_index_tbl <- runsims_tbl |>
    mutate(
      chunk_data = future_map2(
        sim_file, cust_params,
        run_pnbd_simulations_chunk,

        .options = furrr_options(
          globals  = c(
            "calculate_event_times", "rgamma_mucv", "gamma_mucv2shaperate",
            "generate_pnbd_validation_transactions"
            ),
          packages   = c("tidyverse", "fs"),
          scheduling = Inf,
          seed       = 421
          ),
        .progress = TRUE
        )
      )
}


pnbd_nonhier_fixed_validsims_index_tbl |> glimpse()
```

We now want to load up the summary statistics for each of our customers for
later analysis.


```{r retrieve_pnbd_nonhier_fixed_simstats}
#| echo: TRUE

retrieve_sim_stats <- ~ .x |>
  read_rds() |>
  select(draw_id, sim_tnx_count, sim_tnx_last)


pnbd_nonhier_fixed_simstats_tbl <- pnbd_nonhier_fixed_validsims_index_tbl |>
  mutate(
    sim_data = future_map(
      sim_file, retrieve_sim_stats,

      .options = furrr_options(
        globals    = FALSE,
        packages   = c("tidyverse", "fs"),
        scheduling = Inf
        ),
      .progress = TRUE
      )
    ) |>
  select(customer_id, sim_data) |>
  unnest(sim_data)

pnbd_nonhier_fixed_simstats_tbl |> glimpse()
```





# R Environment

```{r show_session_info}
#| echo: TRUE
#| message: TRUE

options(width = 120L)
sessioninfo::session_info()
options(width = 80L)
```
